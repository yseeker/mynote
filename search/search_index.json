{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs \u00b6 For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout \u00b6 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Note \u3053\u308c\u306f\u30ce\u30fc\u30c8\u3067\u3059\u3002 Tip \u30d2\u30f3\u30c8\u3067\u3059\u3002 Warning \u3053\u308c\u306f\u8b66\u544a\u3067\u3059 Danger \u3053\u308c\u306f\u5371\u967a\u3067\u3059\u3002 Success \u3053\u308c\u306f\u6210\u529f\u3067\u3059\u3002 Failure \u3053\u308c\u306f\u5931\u6557\u3067\u3059\u3002 Bug \u3053\u308c\u306f\u30d0\u30b0\u3067\u3059\u3002 Summary \u3053\u308c\u306f\u6982\u8981\u3067\u3059\u3002","title":"plotly"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Note \u3053\u308c\u306f\u30ce\u30fc\u30c8\u3067\u3059\u3002 Tip \u30d2\u30f3\u30c8\u3067\u3059\u3002 Warning \u3053\u308c\u306f\u8b66\u544a\u3067\u3059 Danger \u3053\u308c\u306f\u5371\u967a\u3067\u3059\u3002 Success \u3053\u308c\u306f\u6210\u529f\u3067\u3059\u3002 Failure \u3053\u308c\u306f\u5931\u6557\u3067\u3059\u3002 Bug \u3053\u308c\u306f\u30d0\u30b0\u3067\u3059\u3002 Summary \u3053\u308c\u306f\u6982\u8981\u3067\u3059\u3002","title":"Project layout"},{"location":"tez_templates/","text":"Tez template \u00b6 Tez \u3092\u4f7f\u3063\u305f\u753b\u50cf\u5206\u985e\u7528Template \u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u30a4\u30f3\u30dd\u30fc\u30c8 \u00b6 import os import sys import random from tqdm import tqdm import pandas as pd import numpy as np from sklearn import metrics from sklearn.model_selection import StratifiedKFold import torch import torch.nn as nn import cv2 from PIL import Image import albumentations as A tez_path = '../input/tez-lib' efnet_path = '../input/efficientnet-pytorch/EfficientNet-PyTorch/EfficientNet-PyTorch-master' #timm_path = '../input/pytorch-image-models-master' sys . path . append ( tez_path ) sys . path . append ( efnet_path ) #sys.path.append(timm_path) # timm_path = '../input/pytorch-image-models-master/' # sys.path.append(timm_path) import tez from tez.datasets import ImageDataset from tez.callbacks import EarlyStopping import timm \u30b7\u30fc\u30c9\u306e\u8a2d\u5b9a \u00b6 def set_seed ( seed = 0 ): np . random . seed ( seed ) random_state = np . random . RandomState ( seed ) random . seed ( seed ) torch . manual_seed ( seed ) torch . cuda . manual_seed ( seed ) torch . backends . cudnn . deterministic = True torch . backends . cudnn . benchmark = False os . environ [ 'PYTHONHASHSEED' ] = str ( seed ) return random_state class ClassificationDataset(): def init (self, image_paths, targets, transform = None): self.image_paths = image_paths self.targets = targets self.transform = None def __len__(self): return len(self.image_paths) def __getitem__(self, item): targets = self.targets[item] image1 = np.load(self.image_paths[item]).astype(float) image = np.vstack(image1).transpose((1, 0)).astype(np.float32)[np.newaxis, ] # image = np.load(self.image_paths[item]).astype(np.float32) # image = np.vstack(image).transpose((1, 0)) # image = cv2.resize(image, dsize=(224,224), interpolation=cv2.INTER_CUBIC) # image = image[np.newaxis, :, :] if self.transform: image = self.transform(image=image)[\"image\"] return { \"image\": torch.tensor(image, dtype=torch.float), \"targets\": torch.tensor(targets, dtype=torch.float), } class CustomNN(tez.Model): def init (self, model_name, input_channels, out_dim, pretrained = True, pretrained_path = None): super(). init () self.conv1 = nn.Conv2d(1, 3, kernel_size=3, stride=1, padding=3, bias=False) self.mynet = timm.create_model(model_name, pretrained = pretrained, in_chans=input_channels) if not pretrained: self.mynet.load_state_dict(torch.load(pretrained_path)) if model_name in timm_efficientnet_family: self.mynet.classifier = nn.Linear(self.mynet.classifier.in_features, out_dim) elif model_name in timm_resnet_family: self.mynet.fc = nn.Linear(self.mynet.num_features, out_dim) elif model_name in timm_vit_famity | timm_swint_family: self.mynet.head = nn.Linear(self.mynet.head.in_features, out_dim) def forward(self, image, targets=None): image = self.conv1(image) outputs = self.mynet(image) if targets is not None: loss = nn.BCEWithLogitsLoss()(outputs, targets.view(-1, 1)) metrics = self.monitor_metrics(outputs, targets) return outputs, loss, metrics return outputs, None, None def monitor_metrics(self, outputs, targets): outputs = outputs.cpu().detach().numpy() targets = targets.cpu().detach().numpy() if len(np.unique(targets)) > 1: roc_auc = metrics.roc_auc_score(targets, outputs) else: roc_auc = 1.0 return {\"roc_auc\": roc_auc} def fetch_optimizer(self): opt = torch.optim.Adam(self.parameters(), lr=5e-4) return opt def fetch_scheduler(self): sch = torch.optim.lr_scheduler.CosineAnnealingWarmRestarts( self.optimizer, T_0=10, T_mult=1, eta_min=1e-6, last_epoch=-1 ) #sch = torch.optim.lr_scheduler.CyclicLR(optimizer, base_lr=0.001, max_lr=5e-4, gamma=0.9, cycle_momentum=False, #step_size_up=1400,step_size_down=1400, mode=\"triangular2\") return sch Training \u00b6 random_state = set_seed(2021) train_aug = A.Compose( [ #A.RandomResizedCrop(256, 256), #A.Transpose(p=0.5), #A.HorizontalFlip(p=0.5), A.VerticalFlip(p=0.5), A.ShiftScaleRotate(p=0.5), A.MotionBlur(p=0.5), ] ) df = pd.read_csv('../input/ /train_labels.csv') df['img_path'] = df['id'].apply(lambda x: f'../input/ /train/{x[0]}/{x}.npy') X = df.img_path.values Y = df.target.values model_name = 'efficientnetv2_rw_s' models = [] device = \"cuda\" Batch_Size = 16 epochs = 5 input_channels = 3 out_dim = 1 fold_cnt = 1 num_of_Fold = 2 skf = StratifiedKFold(n_splits = num_of_Fold) for train_index, test_index in skf.split(X, Y): train_images, valid_images = X[train_index], X[test_index] train_targets, valid_targets = Y[train_index], Y[test_index] train_dataset = ClassificationDataset( image_paths=train_images, targets=train_targets, transform = train_aug ) valid_dataset = ClassificationDataset( image_paths=valid_images, targets=valid_targets, transform = train_aug ) model = CustomNN( model_name = model_name, input_channels = input_channels, out_dim = out_dim ) es = EarlyStopping( monitor=\"valid_roc_auc\", model_path=f'{model_name}_{fold_cnt}fold_{Batch_Size}batch.bin', patience= 2, mode=\"max\" ) model.fit( train_dataset = train_dataset, valid_dataset = valid_dataset, train_bs=Batch_Size, valid_bs=Batch_Size, device=device, epochs=epochs, callbacks=[es], fp16=True, ) model.save(f'{model_name}_{fold_cnt}fold_{Batch_Size}batch.bin') models.append(model) fold_cnt += 1 ```","title":"Tez templates"},{"location":"tez_templates/#tez-template","text":"Tez \u3092\u4f7f\u3063\u305f\u753b\u50cf\u5206\u985e\u7528Template","title":"Tez template"},{"location":"tez_templates/#_1","text":"import os import sys import random from tqdm import tqdm import pandas as pd import numpy as np from sklearn import metrics from sklearn.model_selection import StratifiedKFold import torch import torch.nn as nn import cv2 from PIL import Image import albumentations as A tez_path = '../input/tez-lib' efnet_path = '../input/efficientnet-pytorch/EfficientNet-PyTorch/EfficientNet-PyTorch-master' #timm_path = '../input/pytorch-image-models-master' sys . path . append ( tez_path ) sys . path . append ( efnet_path ) #sys.path.append(timm_path) # timm_path = '../input/pytorch-image-models-master/' # sys.path.append(timm_path) import tez from tez.datasets import ImageDataset from tez.callbacks import EarlyStopping import timm","title":"\u30e9\u30a4\u30d6\u30e9\u30ea\u306e\u30a4\u30f3\u30dd\u30fc\u30c8"},{"location":"tez_templates/#_2","text":"def set_seed ( seed = 0 ): np . random . seed ( seed ) random_state = np . random . RandomState ( seed ) random . seed ( seed ) torch . manual_seed ( seed ) torch . cuda . manual_seed ( seed ) torch . backends . cudnn . deterministic = True torch . backends . cudnn . benchmark = False os . environ [ 'PYTHONHASHSEED' ] = str ( seed ) return random_state class ClassificationDataset(): def init (self, image_paths, targets, transform = None): self.image_paths = image_paths self.targets = targets self.transform = None def __len__(self): return len(self.image_paths) def __getitem__(self, item): targets = self.targets[item] image1 = np.load(self.image_paths[item]).astype(float) image = np.vstack(image1).transpose((1, 0)).astype(np.float32)[np.newaxis, ] # image = np.load(self.image_paths[item]).astype(np.float32) # image = np.vstack(image).transpose((1, 0)) # image = cv2.resize(image, dsize=(224,224), interpolation=cv2.INTER_CUBIC) # image = image[np.newaxis, :, :] if self.transform: image = self.transform(image=image)[\"image\"] return { \"image\": torch.tensor(image, dtype=torch.float), \"targets\": torch.tensor(targets, dtype=torch.float), } class CustomNN(tez.Model): def init (self, model_name, input_channels, out_dim, pretrained = True, pretrained_path = None): super(). init () self.conv1 = nn.Conv2d(1, 3, kernel_size=3, stride=1, padding=3, bias=False) self.mynet = timm.create_model(model_name, pretrained = pretrained, in_chans=input_channels) if not pretrained: self.mynet.load_state_dict(torch.load(pretrained_path)) if model_name in timm_efficientnet_family: self.mynet.classifier = nn.Linear(self.mynet.classifier.in_features, out_dim) elif model_name in timm_resnet_family: self.mynet.fc = nn.Linear(self.mynet.num_features, out_dim) elif model_name in timm_vit_famity | timm_swint_family: self.mynet.head = nn.Linear(self.mynet.head.in_features, out_dim) def forward(self, image, targets=None): image = self.conv1(image) outputs = self.mynet(image) if targets is not None: loss = nn.BCEWithLogitsLoss()(outputs, targets.view(-1, 1)) metrics = self.monitor_metrics(outputs, targets) return outputs, loss, metrics return outputs, None, None def monitor_metrics(self, outputs, targets): outputs = outputs.cpu().detach().numpy() targets = targets.cpu().detach().numpy() if len(np.unique(targets)) > 1: roc_auc = metrics.roc_auc_score(targets, outputs) else: roc_auc = 1.0 return {\"roc_auc\": roc_auc} def fetch_optimizer(self): opt = torch.optim.Adam(self.parameters(), lr=5e-4) return opt def fetch_scheduler(self): sch = torch.optim.lr_scheduler.CosineAnnealingWarmRestarts( self.optimizer, T_0=10, T_mult=1, eta_min=1e-6, last_epoch=-1 ) #sch = torch.optim.lr_scheduler.CyclicLR(optimizer, base_lr=0.001, max_lr=5e-4, gamma=0.9, cycle_momentum=False, #step_size_up=1400,step_size_down=1400, mode=\"triangular2\") return sch","title":"\u30b7\u30fc\u30c9\u306e\u8a2d\u5b9a"},{"location":"tez_templates/#training","text":"random_state = set_seed(2021) train_aug = A.Compose( [ #A.RandomResizedCrop(256, 256), #A.Transpose(p=0.5), #A.HorizontalFlip(p=0.5), A.VerticalFlip(p=0.5), A.ShiftScaleRotate(p=0.5), A.MotionBlur(p=0.5), ] ) df = pd.read_csv('../input/ /train_labels.csv') df['img_path'] = df['id'].apply(lambda x: f'../input/ /train/{x[0]}/{x}.npy') X = df.img_path.values Y = df.target.values model_name = 'efficientnetv2_rw_s' models = [] device = \"cuda\" Batch_Size = 16 epochs = 5 input_channels = 3 out_dim = 1 fold_cnt = 1 num_of_Fold = 2 skf = StratifiedKFold(n_splits = num_of_Fold) for train_index, test_index in skf.split(X, Y): train_images, valid_images = X[train_index], X[test_index] train_targets, valid_targets = Y[train_index], Y[test_index] train_dataset = ClassificationDataset( image_paths=train_images, targets=train_targets, transform = train_aug ) valid_dataset = ClassificationDataset( image_paths=valid_images, targets=valid_targets, transform = train_aug ) model = CustomNN( model_name = model_name, input_channels = input_channels, out_dim = out_dim ) es = EarlyStopping( monitor=\"valid_roc_auc\", model_path=f'{model_name}_{fold_cnt}fold_{Batch_Size}batch.bin', patience= 2, mode=\"max\" ) model.fit( train_dataset = train_dataset, valid_dataset = valid_dataset, train_bs=Batch_Size, valid_bs=Batch_Size, device=device, epochs=epochs, callbacks=[es], fp16=True, ) model.save(f'{model_name}_{fold_cnt}fold_{Batch_Size}batch.bin') models.append(model) fold_cnt += 1 ```","title":"Training"}]}